import { array, i32, i8, ptrAny, struct, u32, u64, u8 } from '@bunbox/struct';

// MARK: Vulkan 1.2 Structures

export const vkPhysicalDeviceVulkan11Features = struct({
  sType: i32(),
  pNext: ptrAny(),
  storageBuffer16BitAccess: u32(),
  uniformAndStorageBuffer16BitAccess: u32(),
  storagePushConstant16: u32(),
  storageInputOutput16: u32(),
  multiview: u32(),
  multiviewGeometryShader: u32(),
  multiviewTessellationShader: u32(),
  variablePointersStorageBuffer: u32(),
  variablePointers: u32(),
  protectedMemory: u32(),
  samplerYcbcrConversion: u32(),
  shaderDrawParameters: u32(),
});

export const vkPhysicalDeviceVulkan11Properties = struct({
  sType: i32(),
  pNext: ptrAny(),
  deviceUUID: array(u8(), 16),
  driverUUID: array(u8(), 16),
  deviceLUID: array(u8(), 8),
  deviceNodeMask: u32(),
  deviceLUIDValid: u32(),
  subgroupSize: u32(),
  subgroupSupportedStages: u32(),
  subgroupSupportedOperations: u32(),
  subgroupQuadOperationsInAllStages: u32(),
  pointClippingBehavior: i32(),
  maxMultiviewViewCount: u32(),
  maxMultiviewInstanceIndex: u32(),
  protectedNoFault: u32(),
  maxPerSetDescriptors: u32(),
  maxMemoryAllocationSize: u64(),
});

export const vkPhysicalDeviceVulkan12Features = struct({
  sType: i32(),
  pNext: ptrAny(),
  samplerMirrorClampToEdge: u32(),
  drawIndirectCount: u32(),
  storageBuffer8BitAccess: u32(),
  uniformAndStorageBuffer8BitAccess: u32(),
  storagePushConstant8: u32(),
  shaderBufferInt64Atomics: u32(),
  shaderSharedInt64Atomics: u32(),
  shaderFloat16: u32(),
  shaderInt8: u32(),
  descriptorIndexing: u32(),
  shaderInputAttachmentArrayDynamicIndexing: u32(),
  shaderUniformTexelBufferArrayDynamicIndexing: u32(),
  shaderStorageTexelBufferArrayDynamicIndexing: u32(),
  shaderUniformBufferArrayNonUniformIndexing: u32(),
  shaderSampledImageArrayNonUniformIndexing: u32(),
  shaderStorageBufferArrayNonUniformIndexing: u32(),
  shaderStorageImageArrayNonUniformIndexing: u32(),
  shaderInputAttachmentArrayNonUniformIndexing: u32(),
  shaderUniformTexelBufferArrayNonUniformIndexing: u32(),
  shaderStorageTexelBufferArrayNonUniformIndexing: u32(),
  descriptorBindingUniformBufferUpdateAfterBind: u32(),
  descriptorBindingSampledImageUpdateAfterBind: u32(),
  descriptorBindingStorageImageUpdateAfterBind: u32(),
  descriptorBindingStorageBufferUpdateAfterBind: u32(),
  descriptorBindingUniformTexelBufferUpdateAfterBind: u32(),
  descriptorBindingStorageTexelBufferUpdateAfterBind: u32(),
  descriptorBindingUpdateUnusedWhilePending: u32(),
  descriptorBindingPartiallyBound: u32(),
  descriptorBindingVariableDescriptorCount: u32(),
  runtimeDescriptorArray: u32(),
  samplerFilterMinmax: u32(),
  scalarBlockLayout: u32(),
  imagelessFramebuffer: u32(),
  uniformBufferStandardLayout: u32(),
  shaderSubgroupExtendedTypes: u32(),
  separateDepthStencilLayouts: u32(),
  hostQueryReset: u32(),
  timelineSemaphore: u32(),
  bufferDeviceAddress: u32(),
  bufferDeviceAddressCaptureReplay: u32(),
  bufferDeviceAddressMultiDevice: u32(),
  vulkanMemoryModel: u32(),
  vulkanMemoryModelDeviceScope: u32(),
  vulkanMemoryModelAvailabilityVisibilityChains: u32(),
  shaderOutputViewportIndex: u32(),
  shaderOutputLayer: u32(),
  subgroupBroadcastDynamicId: u32(),
});

export const vkPhysicalDeviceVulkan12Properties = struct({
  sType: i32(),
  pNext: ptrAny(),
  driverID: i32(),
  driverName: array(i8(), 256),
  driverInfo: array(i8(), 256),
  conformanceVersion: struct({
    major: u32(),
    minor: u32(),
    subminor: u32(),
    patch: u32(),
  }),
  denormBehaviorIndependence: i32(),
  roundingModeIndependence: i32(),
  shaderSignedZeroInfNanPreserveFloat16: u32(),
  shaderSignedZeroInfNanPreserveFloat32: u32(),
  shaderSignedZeroInfNanPreserveFloat64: u32(),
  shaderDenormPreserveFloat16: u32(),
  shaderDenormPreserveFloat32: u32(),
  shaderDenormPreserveFloat64: u32(),
  shaderDenormFlushToZeroFloat16: u32(),
  shaderDenormFlushToZeroFloat32: u32(),
  shaderDenormFlushToZeroFloat64: u32(),
  shaderRoundingModeRTEFloat16: u32(),
  shaderRoundingModeRTEFloat32: u32(),
  shaderRoundingModeRTEFloat64: u32(),
  shaderRoundingModeRTZFloat16: u32(),
  shaderRoundingModeRTZFloat32: u32(),
  shaderRoundingModeRTZFloat64: u32(),
  maxUpdateAfterBindDescriptorsInAllPools: u32(),
  shaderUniformBufferArrayNonUniformIndexingNative: u32(),
  shaderSampledImageArrayNonUniformIndexingNative: u32(),
  shaderStorageBufferArrayNonUniformIndexingNative: u32(),
  shaderStorageImageArrayNonUniformIndexingNative: u32(),
  shaderInputAttachmentArrayNonUniformIndexingNative: u32(),
  robustBufferAccessUpdateAfterBind: u32(),
  quadDivergentImplicitLod: u32(),
  maxPerStageDescriptorUpdateAfterBindSamplers: u32(),
  maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32(),
  maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32(),
  maxPerStageDescriptorUpdateAfterBindSampledImages: u32(),
  maxPerStageDescriptorUpdateAfterBindStorageImages: u32(),
  maxPerStageDescriptorUpdateAfterBindInputAttachments: u32(),
  maxPerStageUpdateAfterBindResources: u32(),
  maxDescriptorSetUpdateAfterBindSamplers: u32(),
  maxDescriptorSetUpdateAfterBindUniformBuffers: u32(),
  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32(),
  maxDescriptorSetUpdateAfterBindStorageBuffers: u32(),
  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32(),
  maxDescriptorSetUpdateAfterBindSampledImages: u32(),
  maxDescriptorSetUpdateAfterBindStorageImages: u32(),
  maxDescriptorSetUpdateAfterBindInputAttachments: u32(),
  supportedDepthResolveModes: u32(),
  supportedStencilResolveModes: u32(),
  independentResolveNone: u32(),
  independentResolve: u32(),
  filterMinmaxSingleComponentFormats: u32(),
  filterMinmaxImageComponentMapping: u32(),
  maxTimelineSemaphoreValueDifference: u64(),
  framebufferIntegerColorSampleCounts: u32(),
});

export const vkImageFormatListCreateInfo = struct({
  sType: i32(),
  pNext: ptrAny(),
  viewFormatCount: u32(),
  pViewFormats: ptrAny(),
});

export const vkAttachmentDescription2 = struct({
  sType: i32(),
  pNext: ptrAny(),
  flags: u32(),
  format: i32(),
  samples: i32(),
  loadOp: i32(),
  storeOp: i32(),
  stencilLoadOp: i32(),
  stencilStoreOp: i32(),
  initialLayout: i32(),
  finalLayout: i32(),
});

export const vkAttachmentReference2 = struct({
  sType: i32(),
  pNext: ptrAny(),
  attachment: u32(),
  layout: i32(),
  aspectMask: u32(),
});

export const vkSubpassDescription2 = struct({
  sType: i32(),
  pNext: ptrAny(),
  flags: u32(),
  pipelineBindPoint: i32(),
  viewMask: u32(),
  inputAttachmentCount: u32(),
  pInputAttachments: ptrAny(),
  colorAttachmentCount: u32(),
  pColorAttachments: ptrAny(),
  pResolveAttachments: ptrAny(),
  pDepthStencilAttachment: ptrAny(),
  preserveAttachmentCount: u32(),
  pPreserveAttachments: ptrAny(),
});

export const vkSubpassDependency2 = struct({
  sType: i32(),
  pNext: ptrAny(),
  srcSubpass: u32(),
  dstSubpass: u32(),
  srcStageMask: u32(),
  dstStageMask: u32(),
  srcAccessMask: u32(),
  dstAccessMask: u32(),
  dependencyFlags: u32(),
  viewOffset: i32(),
});

export const vkRenderPassCreateInfo2 = struct({
  sType: i32(),
  pNext: ptrAny(),
  flags: u32(),
  attachmentCount: u32(),
  pAttachments: ptrAny(),
  subpassCount: u32(),
  pSubpasses: ptrAny(),
  dependencyCount: u32(),
  pDependencies: ptrAny(),
  correlatedViewMaskCount: u32(),
  pCorrelatedViewMasks: ptrAny(),
});

export const vkSemaphoreTypeCreateInfo = struct({
  sType: i32(),
  pNext: ptrAny(),
  semaphoreType: i32(),
  initialValue: u64(),
});

export const vkTimelineSemaphoreSubmitInfo = struct({
  sType: i32(),
  pNext: ptrAny(),
  waitSemaphoreValueCount: u32(),
  pWaitSemaphoreValues: ptrAny(),
  signalSemaphoreValueCount: u32(),
  pSignalSemaphoreValues: ptrAny(),
});

export const vkSemaphoreWaitInfo = struct({
  sType: i32(),
  pNext: ptrAny(),
  flags: u32(),
  semaphoreCount: u32(),
  pSemaphores: ptrAny(),
  pValues: ptrAny(),
});

export const vkSemaphoreSignalInfo = struct({
  sType: i32(),
  pNext: ptrAny(),
  semaphore: ptrAny(),
  value: u64(),
});

export const vkBufferDeviceAddressInfo = struct({
  sType: i32(),
  pNext: ptrAny(),
  buffer: ptrAny(),
});

export const vkDescriptorSetLayoutBindingFlagsCreateInfo = struct({
  sType: i32(),
  pNext: ptrAny(),
  bindingCount: u32(),
  pBindingFlags: ptrAny(),
});

export const vkPhysicalDeviceDescriptorIndexingFeatures = struct({
  sType: i32(),
  pNext: ptrAny(),
  shaderInputAttachmentArrayDynamicIndexing: u32(),
  shaderUniformTexelBufferArrayDynamicIndexing: u32(),
  shaderStorageTexelBufferArrayDynamicIndexing: u32(),
  shaderUniformBufferArrayNonUniformIndexing: u32(),
  shaderSampledImageArrayNonUniformIndexing: u32(),
  shaderStorageBufferArrayNonUniformIndexing: u32(),
  shaderStorageImageArrayNonUniformIndexing: u32(),
  shaderInputAttachmentArrayNonUniformIndexing: u32(),
  shaderUniformTexelBufferArrayNonUniformIndexing: u32(),
  shaderStorageTexelBufferArrayNonUniformIndexing: u32(),
  descriptorBindingUniformBufferUpdateAfterBind: u32(),
  descriptorBindingSampledImageUpdateAfterBind: u32(),
  descriptorBindingStorageImageUpdateAfterBind: u32(),
  descriptorBindingStorageBufferUpdateAfterBind: u32(),
  descriptorBindingUniformTexelBufferUpdateAfterBind: u32(),
  descriptorBindingStorageTexelBufferUpdateAfterBind: u32(),
  descriptorBindingUpdateUnusedWhilePending: u32(),
  descriptorBindingPartiallyBound: u32(),
  descriptorBindingVariableDescriptorCount: u32(),
  runtimeDescriptorArray: u32(),
});
